# 面试中被问到的问题

redis 高可用 集群模式和哨兵模式的区别，优缺点

```
集群模式: 
优点：
高可扩展性：集群模式支持分布式数据存储，可以将数据分散到多个节点上，实现水平扩展。
高性能：集群模式允许并行处理多个命令请求，提供更好的读写性能。
高可用性：集群模式中的数据会在多个节点上进行复制，当某个节点发生故障时，其他节点可以继续提供服务，不会导致系统不可用
哨兵模式：
优点：
自动故障转移：哨兵模式使用哨兵节点监控主节点和从节点的状态，当主节点发生故障时，自动将一个从节点提升为新的主节点，实现故障转移。
简单配置：相对于集群模式，哨兵模式的配置相对简单，只需要配置哨兵节点和主节点的信息。
缺点：
单点故障：哨兵模式中的哨兵节点本身也可能发生故障，造成系统的不可用。
读写性能瓶颈：在哨兵模式下，所有的写操作都需要通过主节点进行，可能会造成主节点的性能瓶颈。
```

redis 冗余和分片

nginx 支持几层转发 怎么做

mysql 复制类型 

mysql 索引，什么情况要用到索引 有什么索引类型

mysql 去重 

```
使用 DISTINCT 关键字：在 SELECT 查询语句中，可以使用 DISTINCT 关键字来去除结果集中的重复记录
SELECT DISTINCT column1, column2 FROM your_table;
```

mysql 导出 只导出表结构  

```
mysqldump -u <用户名> -p --no-data <数据库名> > <输出文件名>.sql
```

mysql 备份方法



mysql 误删怎么去找回数据



mysql Relay Log在复制中可能会遇到一些问题，如Relay Log文件损坏、Relay Log与Binlog不一致

```
当Relay Log文件损坏时，可以采取以下步骤来解决该问题：

1. **停止复制进程**：首先，需要停止从数据库上的复制进程，以防止进一步的数据不一致。

1. **备份现有的Relay Log文件**：在进行任何修复操作之前，务必备份现有的Relay Log文件。这样可以确保在修复过程中不会进一步丢失数据。

1. **删除损坏的Relay Log文件**：将损坏的Relay Log文件从从数据库上删除。这可以通过删除相关的Relay Log文件（通常以文件名的数字序列命名）来完成。

1. **重新同步从数据库**：重新同步从数据库与主数据库之间的数据。有多种方法可以进行重新同步，其中一种常见的方法是使用主数据库上的备份文件重新初始化从数据库，并重新开始复制。

   - 如果从数据库上有可用的备份文件，可以使用备份文件进行初始化，并重新配置和启动复制进程。
   - 如果没有可用的备份文件，可以考虑使用主数据库上的快照或增量备份进行初始化，并重新开始复制。
   - 如果主数据库上的数据量较大，可以考虑使用物理备份（如Percona XtraBackup）或逻辑备份（如mysqldump）进行数据复制。

1. **重新启动复制进程**：在完成重新同步后，重新配置和启动从数据库上的复制进程。确保正确设置和指定新的Relay Log文件位置和格式。

请注意，Relay Log文件损坏可能会导致数据不一致，因此在进行修复操作之前务必备份现有的Relay Log文件，并在重新同步后验证数据的一致性。此外，确保从数据库与主数据库的版本和配置相匹配，以避免出现版本或配置不兼容的问题。
```

docker 已经做好了镜像，怎么样替换启动命令



docker 或者 k8s 怎么映射端口

```
docker 可以通过 -p 参数去进行映射端口

k8s 可以通过创建service 对象进行端口映射也可以通过 kubectl expose 来创建service 进行映射
kubectl expose deployment/<deployment-name> --port=   --target-port=  --name=service 
```

k8s的stateful 和 Replicaset和deployment 的区别  rs 和 deployment 的区别

```
stateful 是部署有状态服务的，他适用于需要保持状态的应用程序，例如是数据库 kafka 之类的
replicaset 是管理无状态应用程序的副本，只需维护特定数量的副本
deployment 适用于无状态应用程序，它可以方便地进行应用程序的声明性配置和滚动更新

deployment 提供了一种声明配置和滚动更新 这些是rs没有的，deployment可以管理多个replicaset ,replicaset 可以管理多个pod 同时deplotment 是支持水平扩展的
```

k8s 替换镜像命令和调整副本数命令

```
替换镜像的命令
kubectl set image deployment <容器名称>=<新的镜像名称>

调整副本数命令
kubectl scale deployment/<deplotment-name> --replicas=<数量>
```

k8s 组件 组成 

```
Kubernetes（常简称为K8s）是一个开源的容器编排和管理平台，它由多个组件组成，每个组件负责不同的功能。以下是 Kubernetes 的主要组件：

1. Master 组件：

   - kube-apiserver：提供 Kubernetes API 服务，用于管理和控制整个集群。
   - kube-controller-manager：负责运行控制器，监控集群状态并作出相应的调整。
   - kube-scheduler：负责将 Pod 调度到集群中的合适节点上运行。

1. Node（工作节点）组件：

   - kubelet：在每个节点上运行的主要代理，负责管理节点上的容器和 Pod。
   - kube-proxy：负责为服务实现网络代理和负载均衡。
   - Container Runtime：负责运行容器的底层软件，如Docker、Containerd等。

1. etcd：

   - 分布式键值存储系统，用于保存集群的配置数据、状态和元数据。

1. 其他组件：

   - kube-dns/coredns：提供 DNS 服务，为集群内部的服务提供域名解析。
   - kube-dashboard：提供一个 Web 界面，用于可视化管理和监控集群。
   - Ingress Controller：处理集群外部的入口流量，并将其路由到适当的服务。
   - Persistent Volumes（PV）和 Persistent Volume Claims（PVC）：用于提供持久化存储的抽象接口。

这些组件共同协作，实现了 Kubernetes 的核心功能，如容器编排、自动扩展、服务发现、负载均衡等，使得在 Kubernetes 集群中部署、管理和扩展应用程序变得更加简单和可靠。
```

k8s 存储   pvc 



k8s的service 有几种类型  headless 和其它的有什么区别  

```
Service 一共有4种类型，分别是clusterip, nodeport, loadbalancer headless 
clusterip: clusterip 类型 service 会为pod提供一个虚拟ip ，这个ip 只能在内部集群访问，外部是不可见的
nodeport:  nodeport 类型 的service 会在每个集群节点上选择一个随机的端口将流量转发到这个端口
loadbalancer : loadbalancer 类型的service 通过云服务商提供的负载均衡 自动分配一个外部负载均衡，并将流量转发到service 。在这个类型中一般是用在从云上的负载均衡传递到内部的后端Pod
headless: headless 和以上的都不同， headless 主要的特点是没用clusterip ,目的是直接暴露pod 的网络标识，不提供负载均衡或者代理服务。
需要直接访问pod的ip地址或者实现自定义服务发现可以使用headless ，其它类型的都提供了负载均衡和代理的功能
```

k8s  ingress 怎么将多个微服务多个端口 只暴露使用一个或者几个端口 去使用

```
	
```

k8s Deployment如何进行应用程序的滚动更新？

```
在 Kubernetes 中，我们可以使用 Deployment 对象来进行应用程序的滚动更新。Deployment 提供了一种声明式的方式来定义应用程序的部署和更新策略。首先，我们需要更新应用程序的容器镜像版本，然后通过更新 Deployment 的 Pod 模板来实现滚动更新。我们可以使用 kubectl apply 命令来更新 Deployment。在滚动更新过程中，我们可以配置滚动更新策略，例如 maxSurge 和 maxUnavailable 参数来控制 Pod 的创建和删除速度。通过监控 Deployment 的状态，我们可以了解更新过程的进展情况。如果出现问题，我们可以随时回滚到先前的版本。这样，Kubernetes 提供了一种可靠且灵活的方式来进行应用程序的滚动更新。
```

shell 去重  

```
在shell 里可以用 
sort file.txt | uniq    

sort是将数据排序，uniq 是将相邻的重复行合并为一行
或者使用 grep 
 
grep -v '^$' file.txt | sort | uniq 
grep命令通常用于搜索匹配的行，但结合-v选项可以用来过滤掉重复的行
```

shell 获取变量参数 $1 $2 $0

```
shell 定义变量为$1 $2    $0 代表当前文件或脚本名
```

sed awk jq 

```
sed 
```

shell 判断a文件是否存在，存在则删除



sed 内容替换  xargs 命令使用

```
ps aux | grep jar | xargs kill 
```

prometheus 和zabbix 的区别是什么

